/*
 * Copyright (c) 2015-2016, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include <ti/net/common.h>

#include "huffman.h"

#define HUFFMAN_CODE_TABLE_LEN (sizeof(huffCodeTable)/sizeof(uint16_t))

#define HUFFMAN_CODE_LEADING_ONES_SHIFT       (11)
#define HUFFMAN_CODE_REMAINING_BIT_LEN_SHIFT  (8)

#define HUFFMAN_CODE_LEADING_ONES_MASK       (0x1F)
#define HUFFMAN_CODE_REMAINING_BIT_LEN_MASK  (0x07)
#define HUFFMAN_CODE_REMAINING_BIT_MASK      (0x3F)

#define HUFFMAN_CODE_BIT_LEN_MIN (5)
#define HUFFMAN_CODE_EOS (256)

#define NULL_CHAR_LEN (1)

/*
 *  @brief This table contains compressed format of the Huffman code (RFC 7541)
 *         for every ASCII character.
 *
 *  The compression reduces memory requirement by half and the format is
 *  defined as follows:
 *      1st octet: num of leading 1s in Huffman code (5 bits)
 *          + len of remaining bits in Huffman code (3 bits)
 *      2nd octet: unused bits (2 bits)
 *          + remaining bits in Huffman code (6 bits)
 */
/*
 *  Generated by ti/net/http/pyscripts/genhuffman.py using
 *  Huffman table from RFC 7541
 */
const uint16_t huffCodeTable[] = {
    0x5300, /* (0): 0101001100000000 */
    0x8e18, /* (1): 1000111000011000 */
    0xbd02, /* (2): 1011110100000010 */
    0xbd03, /* (3): 1011110100000011 */
    0xbd04, /* (4): 1011110100000100 */
    0xbd05, /* (5): 1011110100000101 */
    0xbd06, /* (6): 1011110100000110 */
    0xbd07, /* (7): 1011110100000111 */
    0xbd08, /* (8): 1011110100001000 */
    0x9d0a, /* (9): 1001110100001010 */
    0xe200, /* (10): 1110001000000000 */
    0xbd09, /* (11): 1011110100001001 */
    0xbd0a, /* (12): 1011110100001010 */
    0xe201, /* (13): 1110001000000001 */
    0xbd0b, /* (14): 1011110100001011 */
    0xbd0c, /* (15): 1011110100001100 */
    0xbd0d, /* (16): 1011110100001101 */
    0xbd0e, /* (17): 1011110100001110 */
    0xbd0f, /* (18): 1011110100001111 */
    0xc400, /* (19): 1100010000000000 */
    0xc401, /* (20): 1100010000000001 */
    0xc402, /* (21): 1100010000000010 */
    0xe900, /* (22): 1110100100000000 */
    0xc403, /* (23): 1100010000000011 */
    0xc404, /* (24): 1100010000000100 */
    0xc405, /* (25): 1100010000000101 */
    0xc406, /* (26): 1100010000000110 */
    0xc407, /* (27): 1100010000000111 */
    0xcb00, /* (28): 1100101100000000 */
    0xcb01, /* (29): 1100101100000001 */
    0xcb02, /* (30): 1100101100000010 */
    0xcb03, /* (31): 1100101100000011 */
    0x0614, /* (32): 0000011000010100 */
    0x3b00, /* (33): 0011101100000000 */
    0x3b01, /* (34): 0011101100000001 */
    0x4b02, /* (35): 0100101100000010 */
    0x5301, /* (36): 0101001100000001 */
    0x0615, /* (37): 0000011000010101 */
    0x2b00, /* (38): 0010101100000000 */
    0x4302, /* (39): 0100001100000010 */
    0x3b02, /* (40): 0011101100000010 */
    0x3b03, /* (41): 0011101100000011 */
    0x2b01, /* (42): 0010101100000001 */
    0x4303, /* (43): 0100001100000011 */
    0x2b02, /* (44): 0010101100000010 */
    0x0616, /* (45): 0000011000010110 */
    0x0617, /* (46): 0000011000010111 */
    0x0618, /* (47): 0000011000011000 */
    0x0500, /* (48): 0000010100000000 */
    0x0501, /* (49): 0000010100000001 */
    0x0502, /* (50): 0000010100000010 */
    0x0619, /* (51): 0000011000011001 */
    0x061a, /* (52): 0000011000011010 */
    0x061b, /* (53): 0000011000011011 */
    0x061c, /* (54): 0000011000011100 */
    0x061d, /* (55): 0000011000011101 */
    0x061e, /* (56): 0000011000011110 */
    0x061f, /* (57): 0000011000011111 */
    0x0e1c, /* (58): 0000111000011100 */
    0x2b03, /* (59): 0010101100000011 */
    0x6a00, /* (60): 0110101000000000 */
    0x0d00, /* (61): 0000110100000000 */
    0x4b03, /* (62): 0100101100000011 */
    0x4200, /* (63): 0100001000000000 */
    0x5302, /* (64): 0101001100000010 */
    0x0d01, /* (65): 0000110100000001 */
    0x0e1d, /* (66): 0000111000011101 */
    0x0e1e, /* (67): 0000111000011110 */
    0x0e1f, /* (68): 0000111000011111 */
    0x1500, /* (69): 0001010100000000 */
    0x1501, /* (70): 0001010100000001 */
    0x1502, /* (71): 0001010100000010 */
    0x1503, /* (72): 0001010100000011 */
    0x1504, /* (73): 0001010100000100 */
    0x1505, /* (74): 0001010100000101 */
    0x1506, /* (75): 0001010100000110 */
    0x1507, /* (76): 0001010100000111 */
    0x1508, /* (77): 0001010100001000 */
    0x1509, /* (78): 0001010100001001 */
    0x150a, /* (79): 0001010100001010 */
    0x150b, /* (80): 0001010100001011 */
    0x150c, /* (81): 0001010100001100 */
    0x150d, /* (82): 0001010100001101 */
    0x150e, /* (83): 0001010100001110 */
    0x150f, /* (84): 0001010100001111 */
    0x1c00, /* (85): 0001110000000000 */
    0x1c01, /* (86): 0001110000000001 */
    0x1c02, /* (87): 0001110000000010 */
    0x3200, /* (88): 0011001000000000 */
    0x1c03, /* (89): 0001110000000011 */
    0x3201, /* (90): 0011001000000001 */
    0x5303, /* (91): 0101001100000011 */
    0x7c00, /* (92): 0111110000000000 */
    0x5a00, /* (93): 0101101000000000 */
    0x6200, /* (94): 0110001000000000 */
    0x0d02, /* (95): 0000110100000010 */
    0x6a01, /* (96): 0110101000000001 */
    0x0503, /* (97): 0000010100000011 */
    0x0d03, /* (98): 0000110100000011 */
    0x0504, /* (99): 0000010100000100 */
    0x0d04, /* (100): 0000110100000100 */
    0x0505, /* (101): 0000010100000101 */
    0x0d05, /* (102): 0000110100000101 */
    0x0d06, /* (103): 0000110100000110 */
    0x0d07, /* (104): 0000110100000111 */
    0x0506, /* (105): 0000010100000110 */
    0x1c04, /* (106): 0001110000000100 */
    0x1c05, /* (107): 0001110000000101 */
    0x0d08, /* (108): 0000110100001000 */
    0x0d09, /* (109): 0000110100001001 */
    0x0d0a, /* (110): 0000110100001010 */
    0x0507, /* (111): 0000010100000111 */
    0x0d0b, /* (112): 0000110100001011 */
    0x1c06, /* (113): 0001110000000110 */
    0x0d0c, /* (114): 0000110100001100 */
    0x0508, /* (115): 0000010100001000 */
    0x0509, /* (116): 0000010100001001 */
    0x0d0d, /* (117): 0000110100001101 */
    0x1c07, /* (118): 0001110000000111 */
    0x2300, /* (119): 0010001100000000 */
    0x2301, /* (120): 0010001100000001 */
    0x2302, /* (121): 0010001100000010 */
    0x2303, /* (122): 0010001100000011 */
    0x7100, /* (123): 0111000100000000 */
    0x4a00, /* (124): 0100101000000000 */
    0x6201, /* (125): 0110001000000001 */
    0x5a01, /* (126): 0101101000000001 */
    0xd200, /* (127): 1101001000000000 */
    0x7d06, /* (128): 0111110100000110 */
    0x8612, /* (129): 1000011000010010 */
    0x7d07, /* (130): 0111110100000111 */
    0x7d08, /* (131): 0111110100001000 */
    0x8613, /* (132): 1000011000010011 */
    0x8614, /* (133): 1000011000010100 */
    0x8615, /* (134): 1000011000010101 */
    0x8e19, /* (135): 1000111000011001 */
    0x8616, /* (136): 1000011000010110 */
    0x8e1a, /* (137): 1000111000011010 */
    0x8e1b, /* (138): 1000111000011011 */
    0x8e1c, /* (139): 1000111000011100 */
    0x8e1d, /* (140): 1000111000011101 */
    0x8e1e, /* (141): 1000111000011110 */
    0x9d0b, /* (142): 1001110100001011 */
    0x8e1f, /* (143): 1000111000011111 */
    0x9d0c, /* (144): 1001110100001100 */
    0x9d0d, /* (145): 1001110100001101 */
    0x8617, /* (146): 1000011000010111 */
    0x9500, /* (147): 1001010100000000 */
    0x9d0e, /* (148): 1001110100001110 */
    0x9501, /* (149): 1001010100000001 */
    0x9502, /* (150): 1001010100000010 */
    0x9503, /* (151): 1001010100000011 */
    0x9504, /* (152): 1001010100000100 */
    0x7e1c, /* (153): 0111111000011100 */
    0x8618, /* (154): 1000011000011000 */
    0x9505, /* (155): 1001010100000101 */
    0x8619, /* (156): 1000011000011001 */
    0x9506, /* (157): 1001010100000110 */
    0x9507, /* (158): 1001010100000111 */
    0x9d0f, /* (159): 1001110100001111 */
    0x861a, /* (160): 1000011000011010 */
    0x7e1d, /* (161): 0111111000011101 */
    0x7d09, /* (162): 0111110100001001 */
    0x861b, /* (163): 1000011000011011 */
    0x861c, /* (164): 1000011000011100 */
    0x9508, /* (165): 1001010100001000 */
    0x9509, /* (166): 1001010100001001 */
    0x7e1e, /* (167): 0111111000011110 */
    0x950a, /* (168): 1001010100001010 */
    0x861d, /* (169): 1000011000011101 */
    0x861e, /* (170): 1000011000011110 */
    0xa400, /* (171): 1010010000000000 */
    0x7e1f, /* (172): 0111111000011111 */
    0x861f, /* (173): 1000011000011111 */
    0x950b, /* (174): 1001010100001011 */
    0x950c, /* (175): 1001010100001100 */
    0x8500, /* (176): 1000010100000000 */
    0x8501, /* (177): 1000010100000001 */
    0x8d00, /* (178): 1000110100000000 */
    0x8502, /* (179): 1000010100000010 */
    0x950d, /* (180): 1001010100001101 */
    0x8d01, /* (181): 1000110100000001 */
    0x950e, /* (182): 1001010100001110 */
    0x950f, /* (183): 1001010100001111 */
    0x7d0a, /* (184): 0111110100001010 */
    0x8d02, /* (185): 1000110100000010 */
    0x8d03, /* (186): 1000110100000011 */
    0x8d04, /* (187): 1000110100000100 */
    0x9c00, /* (188): 1001110000000000 */
    0x8d05, /* (189): 1000110100000101 */
    0x8d06, /* (190): 1000110100000110 */
    0x9c01, /* (191): 1001110000000001 */
    0xad00, /* (192): 1010110100000000 */
    0xad01, /* (193): 1010110100000001 */
    0x7d0b, /* (194): 0111110100001011 */
    0x7c01, /* (195): 0111110000000001 */
    0x8d07, /* (196): 1000110100000111 */
    0x9c02, /* (197): 1001110000000010 */
    0x8d08, /* (198): 1000110100001000 */
    0xa50c, /* (199): 1010010100001100 */
    0xad02, /* (200): 1010110100000010 */
    0xad03, /* (201): 1010110100000011 */
    0xad04, /* (202): 1010110100000100 */
    0xae1e, /* (203): 1010111000011110 */
    0xae1f, /* (204): 1010111000011111 */
    0xad05, /* (205): 1010110100000101 */
    0xa401, /* (206): 1010010000000001 */
    0xa50d, /* (207): 1010010100001101 */
    0x7c02, /* (208): 0111110000000010 */
    0x8503, /* (209): 1000010100000011 */
    0xad06, /* (210): 1010110100000110 */
    0xb500, /* (211): 1011010100000000 */
    0xb501, /* (212): 1011010100000001 */
    0xad07, /* (213): 1010110100000111 */
    0xb502, /* (214): 1011010100000010 */
    0xa402, /* (215): 1010010000000010 */
    0x8504, /* (216): 1000010100000100 */
    0x8505, /* (217): 1000010100000101 */
    0xad08, /* (218): 1010110100001000 */
    0xad09, /* (219): 1010110100001001 */
    0xd201, /* (220): 1101001000000001 */
    0xb503, /* (221): 1011010100000011 */
    0xb504, /* (222): 1011010100000100 */
    0xb505, /* (223): 1011010100000101 */
    0x7d0c, /* (224): 0111110100001100 */
    0xa403, /* (225): 1010010000000011 */
    0x7d0d, /* (226): 0111110100001101 */
    0x8506, /* (227): 1000010100000110 */
    0x8d09, /* (228): 1000110100001001 */
    0x8507, /* (229): 1000010100000111 */
    0x8508, /* (230): 1000010100001000 */
    0x9c03, /* (231): 1001110000000011 */
    0x8d0a, /* (232): 1000110100001010 */
    0x8d0b, /* (233): 1000110100001011 */
    0xa50e, /* (234): 1010010100001110 */
    0xa50f, /* (235): 1010010100001111 */
    0xa404, /* (236): 1010010000000100 */
    0xa405, /* (237): 1010010000000101 */
    0xad0a, /* (238): 1010110100001010 */
    0x9c04, /* (239): 1001110000000100 */
    0xad0b, /* (240): 1010110100001011 */
    0xb506, /* (241): 1011010100000110 */
    0xad0c, /* (242): 1010110100001100 */
    0xad0d, /* (243): 1010110100001101 */
    0xb507, /* (244): 1011010100000111 */
    0xb508, /* (245): 1011010100001000 */
    0xb509, /* (246): 1011010100001001 */
    0xb50a, /* (247): 1011010100001010 */
    0xb50b, /* (248): 1011010100001011 */
    0xd900, /* (249): 1101100100000000 */
    0xb50c, /* (250): 1011010100001100 */
    0xb50d, /* (251): 1011010100001101 */
    0xb50e, /* (252): 1011010100001110 */
    0xb50f, /* (253): 1011010100001111 */
    0xbc00, /* (254): 1011110000000000 */
    0xad0e, /* (255): 1010110100001110 */
    0xf000, /* (256): 1111000000000000 */
};

/*
 *  ======== decodeHuffCode ========
 *  Decode the huffman code and return ASCII character
 *
 *  This function compares the input 'value' with the decompressed
 *  entries from Huffman code table.
 *
 *  The decompression algorithm uses the following logic to get the
 *  Huffman code:
 *      1st octet: num of leading 1s in Huffman code (5 bits)
 *          + len of remaining bits in Huffman code (3 bits)
 *      2nd octet: unused bits (2 bits)
 *          + remaining bits in Huffman code (6 bits)
 *
 *  Returns the ASCII character on success or -1 on failure.
 */
static int decodeHuffCode(uint32_t value, uint8_t bitCount)
{
    uint16_t i;
    uint32_t huffCode;
    uint8_t prefixLen;
    uint8_t suffixLen;
    uint8_t suffixVal;

    for (i = 0; i < HUFFMAN_CODE_TABLE_LEN; i++) {
        prefixLen = (huffCodeTable[i] >> HUFFMAN_CODE_LEADING_ONES_SHIFT)
                & HUFFMAN_CODE_LEADING_ONES_MASK;
        suffixLen = (huffCodeTable[i] >> HUFFMAN_CODE_REMAINING_BIT_LEN_SHIFT)
                & HUFFMAN_CODE_REMAINING_BIT_LEN_MASK;
        suffixVal = (huffCodeTable[i] & HUFFMAN_CODE_REMAINING_BIT_MASK);

        if (bitCount != (prefixLen + suffixLen)) {
            continue;
        }

        huffCode = 0;

        /* Fill the leading 1s */
        while (prefixLen) {
            huffCode = (huffCode << 1) | 1;
            prefixLen--;
        }
        /* Add the remaining value */
        huffCode <<= suffixLen;
        huffCode += suffixVal;

        if (huffCode == value) {
            return (i);
        }
    }

    return (-1);
}

/*
 *  ======== Huffman_decode ========
 *  Decode the Huffman encoded string
 */
int Huffman_decode(uint8_t *encodedStr, uint32_t len, char **decodedStr)
{
    int ret = HUFFMAN_EDECODE;
    int index = 0;
    uint32_t value = 0;
    uint32_t i;
    uint8_t j;
    uint8_t bitCount = 0;
    uint32_t slen = 0;
    char *lstr = NULL;

    *decodedStr = NULL;

    for (i = 0; i < len; i++) {
        /* Copy bit by bit and compare with Huffman table */
        for (j = 0; j < 8; j++) {
            value = (value << 1) | ((encodedStr[i] >> (7 - j)) & 0x1);
            bitCount++;

            if (bitCount >= HUFFMAN_CODE_BIT_LEN_MIN) {
                index = decodeHuffCode(value, bitCount);
                if (index >= 0) {
                    if (index == HUFFMAN_CODE_EOS) {
                        free(*decodedStr);
                        *decodedStr = NULL;

                        ret = HUFFMAN_EDECODE;
                    }
                    else {
                        slen++;

                        lstr = (char *) realloc(*decodedStr, slen
                                + NULL_CHAR_LEN);
                        if (lstr) {
                            lstr[slen - 1] = (uint8_t)index;
                            *decodedStr = lstr;

                            bitCount = 0;
                            value = 0;
                        }
                        else {
                            free(*decodedStr);
                            *decodedStr = NULL;

                            ret = HUFFMAN_EINSUFFICIENTHEAP;
                        }
                    }
                }
            }
        }
    }

    if (*decodedStr) {
        (*decodedStr)[slen] = '\0';
        ret = 0;
    }

    return (ret);
}
